##########################################################
#                   Plastome.pm                          #
##########################################################
# This module can be used to generate high quality       #
# graphical maps of circular plastome DNA molecules.     #
# Possible output file types are                         #
# PostScript (PS) and all types supported by the         #
# ImageMagick library (although we restricted it to the  #
# most common types (png, jpg, tif and gif)              #
# The module uses various open source modules and we     #
# wish to thank/acknowledge the creators of these.       #
#                                                        #
# The module defines the class Plastome that provides    #
# an easy to use object-oriented interface to (hopefully)#
# all functions required to flexibly generate            #
# plastome maps.                                         #
#                                                        #
# Authors:                                               #
# Marc Lohse and Oliver Drechsel                         #
# Max-Planck-Institute of molecular                      #
# plant physiology                                       #
# Am Muehlenberg 1                                       #
# 14476 Potsdam-Golm                                     #
# lohse@mpimp-golm.mpg.de                                #
# drechsel@mpimp-golm.mpg.de                             #
#                                                        #
##########################################################


=head1 NAME

GeneMap::Plastome
Create high quality circular maps of plastome sequences from Genbank files or
accession numbers

=head1 SYNOPSIS

 use GeneMap::Plastome;

 # create a new Plastome object
 # to create a mitochondrial genome map, simply replace
 # the 'Plastome' by 'Chondriome' - 'Default' creates a 
 # map using a non organelle-specific set of feature class
 # definitions
 my $p = GeneMap::Plastome->new(accnum  => 'Z00044', # tobacco 2006 version                                                  
					           gc_cont => 1); # draw GC content graph

 # autodetect inverted repeat borders and include them in the map
 # this requires the small irscan tool to be installed in your path
 $p->findIRborders();					           

 # create map and write to PostScript file 
 # available types are tif, jpg, gif, png 
 $p->createMap(outputfile => "plastome.ps", type => 'ps'); 


 # list all feature types in the GenBank entry (or file, if provided)
 my @types = $p->getFeatureTypes();
 print "types found in \$p: @types\n";

 # this feature type will now be drawn if you invoke ->createMap again
 $p->setDrawFlag(featureID => 'unclassified', drawflag => 1);

 # add new feature type to the list of features that will we included in the map
 $p->addDrawableFeature(
					type => 'gene',
					pattern => '.*',				
					color => [171,200, 157],	
					fullname => 'any gene', 						
					drawflag => 1
					);


=head1 DESCRIPTION

This module provides an easy way to generate publication-quality plastome maps in a flexible way - since it's using the Image::Magick wrapper module you can export the created map in any image format that is supported by ImageMagick or use the PostScript file that is generated by default. We have also set up a website that is using the Plastome module - users are advised to make use of this site since any new (debugged) versions of the module will be at work there: 

L<http://ogdraw.mpimp-golm.mpg.de>

=cut

package GeneMap::Plastome;

#
# include modules
#

use strict;
use Carp;
use Data::Dumper;
use File::Spec;

use Bio::Root::Root;
use Bio::SeqIO;
use Bio::SeqFeature::Generic;
use Bio::Restriction::Analysis;
use Bio::Perl;

use PostScript::Simple;
use Image::Magick;

use XML::Generator;
use XML::Simple;

use GeneMap::Plastome::ToolBox;
use GeneMap::Plastome::BoundingBox;
use GeneMap::Chondriome;
use GeneMap::Linear;

use vars qw/@ISA/;

our @ISA = qw/Bio::Root::Root/;

our $VERSION = '1.1.1';


#
# constants
#

use constant BLACK  => 0,   0,   0;
use constant WHITE  => 255, 255, 255;
use constant RED    => 255, 0,   0;
use constant GREEN  => 0,   255, 0;
use constant BLUE   => 0,   0,   255;
use constant ATP    => 151, 190, 13;
use constant PSA    => 0,   102, 44;
use constant PSB    => 50,  137, 37;
use constant RBCL   => 31,  161, 45;
use constant PET    => 121, 156, 19;
use constant TRN    => 22,  41,  131;
use constant ORF    => 87,  185, 168;
use constant NDH    => 255, 236, 0;
use constant CLP    => 233, 93,  15;
use constant RRN    => 226, 0,   26;
use constant RPO    => 189, 18,  32;
use constant RPS    => 219, 170, 115;
use constant RPL    => 158, 119, 66;
use constant YCF    => 255, 250, 208;
use constant ORI    => 255, 128, 128;
use constant VIOLET => 171, 37,  157;
use constant DARK_RED => 127,  0,  0;
use constant RE_LINE_COLOR => 255, 175, 175;

use constant TRUE 		        => 1;    # quite "unperlish" but improves the readability (at least for me)
use constant FALSE              => undef();# was 0
use constant PI               	=> 3.1415926535897932384626433832795;
use constant MAX_LABEL_LENGTH   => 16; # if the gb file contains labels longer than this labelsOK will return FALSE
use constant MIN_INNER          => 1.4; #   minimal angle required for non-overlapping inner labels
use constant MIN_OUTER          => 1.1; #   minimal angle required for non-overlapping outer labels
use constant MIN_OPT_OUTER      => 1.2; # minimal angle required for outwards-shifted labels
use constant MIN_OPT_INNER      => 1.8;  # minimal angle required for inwards-shifted labels
use constant MAX_OPT_RUNS       => 3;    # emergency brake for optimization loop
use constant LABEL_SHIFT        => 3.9;    # shift for centering of labels above features
use constant MIN_FRAMED_FEATURE_WIDTH   => 0.3; # minimal width for a feature to be drawn with frame
use constant CENTER_X           => 600; # X coordinate of circle center500
use constant CENTER_Y           => 600; # Y coordinate of circle center
use constant PS_X_SIZE          => 1200; # X size of the PostScript object1000
use constant PS_Y_SIZE          => 1200; # Y size of the PostScript object
use constant CHAR_WIDTH			=> 10; # median char width - - NOT CORRECT
use constant CHAR_HEIGHT		=> 10; # Character height - - has to be checked again
use constant MAX_GENE_SIZE      => 15000; # maximal sensible gene size. required to identify annotation monsters
use constant MIN_SPLIT_SIZE     => 10000; # smaller genes will not be split into sublocations
use constant OPERON_WIDTH       => 7.5;
use constant OPERON_COLOR		=> RED;

#
# graphics default values
#
my $MAIN_RADIUS				= 387.5;
my $RE_LABEL_RADIUS    		= $MAIN_RADIUS + 127.5; # Radius for RE labels
my $OPT_OUTER_RADIUS   		= $MAIN_RADIUS + 67.5;  # radius for outwards-shifted labels
my $OPT_INNER_RADIUS   		= $MAIN_RADIUS - 67.5;  # radius for inwards-shifted labels
my $INSIDE_FEATURE_RADIUS 	= $MAIN_RADIUS - 12.15;
my $OUTSIDE_FEATURE_RADIUS 	= $MAIN_RADIUS + 12.15;
my $INSIDE_LABEL_RADIUS		= $MAIN_RADIUS - 27.5;
my $OUTSIDE_LABEL_RADIUS	= $MAIN_RADIUS + 27.5;

## this has to be adjusted to the actual location of irscreen on your system
## if the relative path doesn't work. We suggest to download the version of
## that matches your operating system and put it (or put a link poiting at it)
## in your PATH.

my $IRSCREEN_PATH = "irscan"; # assuming that the user put it into his/her path
# if ($^O =~ /darwin/) { # running on marcs mac?
# 	$IRSCREEN_PATH = 'GeneMap/irscan_macosx';
# } else {
# 	$IRSCREEN_PATH = 'GeneMap/irscreen';
# }

my %three_to_1 = (
'Ala' => 'A','Cys' => 'C','Asp' => 'D','Glu' => 'E','Phe' => 'F',
'Gly' => 'G','His' => 'H','Ile' => 'I','Lys' => 'K','Leu' => 'L',
'Met' => 'M','Asn' => 'N','Pro' => 'P','Gln' => 'Q','Arg' => 'R',
'Ser' => 'S','Thr' => 'T','Val' => 'V','Trp' => 'W','Tyr' => 'Y',
'*'   => '*','fM' => 'fM'
);

my @allowed_organelles = ('chloroplast', 'mitochondrion');
my  @drawable_types = ('gene', 'intron', 'rRNA', 'tRNA', 'CDS');

# common template for the drawable features list
our @drawable_features = 
(
{type => 'gene', 	pattern => '^psa.*', 			color => [PSA],		fullname => 'photosystem I', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^psb.*',			color => [PSB],		fullname => 'photosystem II', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^pet.*',			color => [PET],		fullname => 'cytochrome b/f complex', 	drawflag => TRUE},
{type => 'gene', 	pattern => '^atp.*', 			color => [ATP],		fullname => 'ATP synthase', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^ndh.*',			color => [NDH],		fullname => 'NADH dehydrogenase', 		drawflag => TRUE},
{type => 'gene', 	pattern => '^rbcl.*', 			color => [RBCL],	fullname => 'RubisCO large subunit', 	drawflag => TRUE},
{type => 'gene', 	pattern => '^rpo.*',			color => [RPO],		fullname => 'RNA polymerase', 			drawflag => TRUE},
{type => 'gene'		,pattern => '^rps.*',			color => [RPS],		fullname => 'ribosomal proteins (SSU)', drawflag => TRUE},
{type => 'gene', 	pattern => '^rpl.*',			color => [RPL],		fullname => 'ribosomal proteins (LSU)', drawflag => TRUE},
{type => 'gene', 	pattern => '(^clp.*)|(^mat.*)',	color => [CLP],		fullname => 'clpP, matK', 				drawflag => TRUE},
{type => 'gene',    pattern => '^trn.*',            color => [TRN],     fullname => 'transfer RNAs',            drawflag => TRUE},
{type => 'gene',    pattern => '^rrn.*',            color => [RRN],     fullname => 'ribosomal RNAs',           drawflag => TRUE},

{type => 'other', 	pattern => '.*',				color => [VIOLET],	fullname => 'other genes', 				drawflag => TRUE},
{type => 'gene',pattern => '^ycf.*', 	     		color => [YCF],		fullname => 'hypothetical chloroplast reading frames (ycf)', drawflag => TRUE},
{type => 'CDS|gene',pattern => '^orf.*',			color => [ORF],		fullname => 'ORFs', 					drawflag => TRUE},
{type => 'gene',    pattern => '.*',                color => [VIOLET],  fullname => 'other genes',              drawflag => TRUE},
{type => 'tRNA', 	pattern => '.*', 				color => [TRN],		fullname => 'transfer RNAs', 			drawflag => TRUE},
{type => 'rRNA', 	pattern => '.*', 				color => [RRN],		fullname => 'ribosomal RNAs', 			drawflag => TRUE},
{type => 'rep_origin', 	pattern => '^ori.*', 		color => [ORI],		fullname => 'origin of replication', 	drawflag => TRUE},
{type => 'intron', 	pattern => '.*',				color => [WHITE],	fullname => 'introns', 					drawflag => TRUE},
{type => '_operon_',pattern => '.*',				color => [RED],		fullname => 'polycistronic transcripts', drawflag => FALSE}
);

###############################################################
#                       PUBLIC METHODS                        #
###############################################################

=head1 METHODS

=head2 new

 Title   : new
 Usage   : my $map = GeneMap::Plastome -> new(
                                        file       => A_FILE,
                                        #accnum    => 'Z00044',
                                        IRAstart   => 1,
                                        IRAend     => 2,
                                        IRBstart   => 3,
                                        IRBend     => 4,
                                        gc_cont    => 1|0)
                                        );
 Function: 	Constructor of GeneMap::Plastome class objects
 Returns : 	Return a reference to a new GeneMap::Plastome object
 Args    : 	file	- specifies a local GenBank file that will be used to draw the map
 accnum	- GenBank accession number of entry to draw the map from
 IRAstart, IRBstart, IRAend, IRBend - exact positions of the inverted repeats
 gc_cont - if set to 1 will include a GC content graph in the map

=cut

sub new    #constructor
{
    my ($invocant, %arg) = @_;
    $invocant = ref($invocant) || $invocant;
    
#    #DEBUG
#    print "INVOCANT  $invocant\n";
    
    &_check_args(\%arg, 'file', 'accnum', 'IRAstart', 'IRBstart', 'IRAend', 'IRBend', 'gc_cont', 'Xsize');
    my ($seqobj, $organelle, $p_featureList, $p_featureTypes, @IRborders, $species, $BACKUP);
    # lokale kopie der Liste, Referenz darauf kommt in die Instanzvariable _drawableFeatures
    # irgendwie ist mir mulmig dabei, aber es scheint zu funktionieren
    my @its_drawableFeatures;
    
    if (!defined($arg{'Xsize'})) {
    	$arg{'Xsize'} = 1000;
    }

    unless ((exists($arg{file})) or (exists($arg{accnum})))
    {
        croak(
            "You have to supply either a GenBank file or a valid accession number"
        );
    }
    
    if ((defined($arg{file})) && ($arg{file} eq 'dummy'))
    {
    	goto RETURN_DUMMY_OBJECT;
    }
    
    if (defined($arg{file}))
    {
        my $seqio =
          Bio::SeqIO->new(-format => 'genbank', -file => $arg{file})
          ;    #open sequence file
        $seqobj = $seqio->next_seq();  # read sequence file into sequence object
		$BACKUP = $seqobj;
    }
    else
    {
        print "ACCNUM UPPERCASED: ".uc($arg{accnum})."<br>";
        $seqobj = get_sequence('genbank', uc($arg{accnum}));
        $BACKUP = $seqobj;
    }
    
    
    # choose proper feature filter according to organelle
    $organelle = _guess_organelle($seqobj->desc()) || 'unknown';
    
    
    if ($organelle eq 'chloroplast')
    {
    	@its_drawableFeatures = @drawable_features;
    } elsif ($organelle eq 'mitochondrial') {
    	@its_drawableFeatures = @GeneMap::Chondriome::drawable_features;
    } else {
    	@its_drawableFeatures = @GeneMap::Default::drawable_features;
    }


    # read in the features from seqobject
    ($p_featureList, $p_featureTypes) = $invocant->_read_contents($seqobj, $arg{'Xsize'});
    
    #check integrity of passed IR border values
    @IRborders = ($arg{IRAstart}, $arg{IRAend}, $arg{IRBstart}, $arg{IRBend});
    foreach my $value (@IRborders)
	{
		next if (!defined($value));
		if (($value =~ /\D/g) || ($value > $seqobj->length()) || ($value < 0))
		{
            $arg{IRAstart} = FALSE;
            $arg{IRAend} = FALSE;
            $arg{IRBstart} = FALSE;
            $arg{IRBend} = FALSE;
            last;
		}
	}
	
	# default Xsize
# 	$args{'Xsize'} = 1000 if (!defined($args{'Xsize'}));
	
	# if the uploaded sequence was no genome or does for some
	# other reason not contain info on the organism  the ->binomial
	# call throws an exception
	eval 
	{	
		$species = $seqobj->species->binomial('FULL');
	}; 
	
	if ($@) 
	{ 
		carp("WARNING: Exception caught: $@");
		$species = "unknown organism";
	}
	
	
	RETURN_DUMMY_OBJECT:
	   
    my $self = {
        _seqobj           => $seqobj,
        _bakobj			  => $BACKUP,
        _featureList      => $p_featureList,
        _featureTypes     => $p_featureTypes,
        _restrictionSites => [], # empty Array ref; will be filled later, if desired
        _IRAstart         => $arg{IRAstart} || FALSE,
        _IRAend           => $arg{IRAend} || FALSE,
        _IRBstart         => $arg{IRBstart} || FALSE,
        _IRBend           => $arg{IRBend} || FALSE,
        _displayName      => $species,
        _psMap            => '',
        _drawableFeatures => \@its_drawableFeatures,
        _gcGraph          => $arg{gc_cont} || FALSE,
        _TIDY			  => FALSE,
        _organelle        => $organelle,
        _outputDPI        => '300x300', # default 
        _is_zoomed		  => FALSE,
        _zoom_start		  => FALSE,
        _zoom_end		  => FALSE,
        _PS_X_SIZE	  	  => $arg{'Xsize'},
        _PS_DRAWABLE_SIZE => ($arg{'Xsize'} - 20 ) || FALSE,
        _ps_legend		  => ''
    };
    bless ($self, $invocant);
    return $self;

}    #end new

# method required for HTML interface to offer 
# the correct set of drawable features

=head2 getOrganelleType

 Title   : getOrganelleType
 Usage   : $map->getOrganelleType()
 Function: 	Tries to guess the type of organelle the GenBank entry originates from
 Returns : 	the name of the organelle as a string : 'chloroplast' | 'mitochondrial' | 'unknown'
 Args    : 	none

=cut

sub getOrganelleType
{
    my $self = shift;
    return $self->{_organelle};
}

=head2 createMap

 Title   : createMap
 Usage   : $map->createMap(outputfile => "foo_map", type => 'jpg', density => '300x300')
 Function: 	Creates the map and writes it to a file
 Returns : 	TRUE on success
 Args    : 	outputfile - path to a writable location where the map will be saved
 			type - either jpg, gif, tiff, png or ps
 			density - resolution of the output - makes sense only for the rasterized image types
 			full_legend - set to 1, if you want to list all gene classes in the legend
 			(not only those that were actually found in the annotation)

=cut

sub createMap
{
    my ($self, %args) = @_;
    &_check_args(\%args, 'outputfile', 'type', 'density', 'full_legend');
    
    croak('Unknown image type!\n')
      unless (&_is_element_of($args{type}, ('ps', 'pdf', 'png', 'jpg', 'tif', 'gif')));
    
    my $shiftSSC = $self->_calc_shiftSSC();
    my $fullLegend = FALSE;
      
    $self->{_outputDPI} = $args{'density'} unless (!defined($args{'density'}));
    
	if (defined($args{'full_legend'})) { $fullLegend = TRUE }
	
    # to be able to include all genes that do not fall in any of the
    # drawable_features categories we have to preprocess the featurelist
    # just before drawing it to set everything that is a gene but no
    # drawable_feature to type "other" which will be drawn in violet
    _preprocess_feature_list($self);

    # disentangle overlapping labels
    _clean_up_labels($self);
    
    # are there still long labels left??
    print "<em>Warning</em>: Some labels are too long!<br>" if (!labelsOK($self));
    
    # re-sort feature list descending according to feature sizes 
    @{$self->{_featureList}} = sort { $b->{'extent'} <=> $a->{'extent'} }
      @{$self->{_featureList}};  

    #store PostScript object returned by _create_graph in _psMap    
   	$self->{_psMap} = $self->_create_graph($shiftSSC, $fullLegend);
    
    
    
    #draw GC graph, if desired
    _draw_GC_graph($self, $shiftSSC) if ($self->{_gcGraph});

    # draw IRs if IR borders are passed
    if (($self->{_IRAstart}) and ($self->{_IRBstart}) and ($self->{_IRAend}) and ($self->{_IRBend}))
    {
        print "adding inverted repeat labels...<br>\n";    #debug
        my ($IRA_start, $IRA_end) = ($self->{_IRAstart}, $self->{_IRAend}) ;
        my ($IRB_start, $IRB_end) = ($self->{_IRBstart}, $self->{_IRBend}) ;
        
        $self->{_psMap} =
          &_draw_IR($shiftSSC, $self->{_psMap}, $self->{_seqobj}, $IRA_start, $IRA_end,
                    $IRB_start, $IRB_end);
#                     where IRA start has to be LSC-IRA and IRB start LSC-IRB border
    }
    
    
	
    # delete user-given extension to avoid duplicated extension
    $args{outputfile} =~ s/\.$args{type}$//i;
    
    # get location of writable dir for temporary files
    my $tmpdir = File::Spec->tmpdir()."/";
    my $tmp = time();

    if ($args{type} eq 'ps')
    {
#         print "writing "
#           . $args{type}
#           . " image: "
#           . $args{outputfile} . ".ps\n";
        $self->{_psMap}->output($args{outputfile} . ".ps");
    }
    else
    {
        my $tempfile = $tmpdir.$tmp;
    
    
#         print "writing "
#           . $args{type}
#           . " image: "
#           . $args{outputfile} . "."
#           . $args{type} . "\n";

        #write temporary ps file
        $self->{_psMap}->output("$tempfile.ps") ;

        my $image = Image::Magick->new();

        $image->Set(
            page    => PS_X_SIZE."x".PS_Y_SIZE,
            density => $self->{_outputDPI},
            units 	=> 'PixelsPerInch,',
            compression => 'LZW' # only needed for tif - seems like it's ignored for other formats
        );

        $image->Read("$tempfile.ps");
        unlink("$tempfile.ps");
        $image->Write($args{outputfile} . "." . $args{type});

    }    #end else

    return TRUE;
}

=head2 getName, setName

 Title   : getName, setName
 Usage   : $map->getName(), $map->setName('foo')
 Function: 	Set the organism name
 Returns : 	the name displayed in the centre region of the map 
 Args    : 	the name as a string (in the case of the setName method)

=cut

sub getName
{
    my $self = shift;
    return $self->{_displayName};
}

sub setName
{
    my ($self, $newName) = @_;
    $self->{_displayName} = $newName;
}

=head2 setIRA, setIRB

 Title   : setIRA, setIRB
 Usage   : $map->setIRA(1, 100000), $map->setIRB(100001, 150000)
 Function: 	Set the location of the inversted repeats manually
 Returns : 	nothing
 Args    : 	the IR start and end positions as integers

=cut

sub setIRA
{
    my ($self, $start, $end) = @_;
    $self->{_IRAstart} = $start;
    $self->{_IRAend} = $end;
}

sub setIRB
{
    my ($self, $start, $end) = @_;
    $self->{_IRBstart} = $start;
    $self->{_IRBend} = $end;
}

=head2 findIRborders

 Title   : findIRborders
 Usage   : $map->findIRborders(precision => 2, word_size => 1000, verbose => 1)
 Function: 	tries to find inverted repeat regions in the sequence
 Returns : 	IRAstart, IRAend, IRBstart, IRBend positions, if found. Otherwise returns false (undef())
 Args    : 	precision - precision for the IR border scan in bp. the lower you choose it the longer it will take
 			word_size - minimal size of inverted repeat region to be recognized as such
 			verbose - prints some info to STDOUT

=cut

sub findIRborders
{
	my ($self, %args) = @_;
	&_check_args(\%args, 'precision', 'word_size', 'verbose');
	my $start_time = time();
	
	#  deprecated: this is now set in irscreen.d
	my $WORD_SIZE = $args{word_size} || 2000;# default word size 2000bp
	my $PRECISION = $args{precision} || 1;# default precision of 2 bp should be OK for graphical output
 	my $VERBOSE   = $args{verbose}   || FALSE;
	
	my $seq = $self->{_seqobj}->seq();
	
	# create temporary file 
	# that contains the sequence
	# as raw text
	my $tmpdir = File::Spec->tmpdir()."/";
	my $tmpfilename = $tmpdir.$start_time;
	
	open SEQFILE, ">$tmpfilename" or die "Could not open file :$!\n";
	print SEQFILE $seq;
	close SEQFILE;
	
	my $borders = `$IRSCREEN_PATH --file=$tmpfilename --wordsize=$WORD_SIZE --precision=$PRECISION`;
	#print $IRSCREEN_PATH, '<br>',$borders; 
	
	if ($borders eq "false")
	{
		print "This sequence does not contain inverted repeats longer than $WORD_SIZE\n";
		return FALSE;
	}
	
	my ($IRA_start,$IRA_end,$IRB_start,$IRB_end) =  split(/;/,$borders);
	$self->setIRA($IRA_start, $IRA_end);
	$self->setIRB($IRB_start, $IRB_end);
	
	my $end_time = time;
	print "with a precision of ".$PRECISION."bp it took ".($end_time-$start_time)."s\n###############\n"
        if ($VERBOSE);
	
 	return $IRA_start, $IRA_end, $IRB_start, $IRB_end;
}

=head2 getFeatureTypes

 Title   : getFeatureTypes
 Usage   : $map->getFeatureTypes()
 Function: 	Returns a list of feature types found in the specific GenBank entry
 Returns : 	an array
 Args    : 	none

=cut

sub getFeatureTypes
{
    my $self = shift;
    return @{$self->{_featureTypes}};
}

=head2 addDrawableFeature

 Title   : addDrawableFeature
 Usage   : $map->addDrawableFeature(fullname => 'Foo feature',
 									pattern	=> '.*',
 									color => [255, 255, 255], #red, green, blue
 									type	=> 'CDS|gene',
 									drawflag => 1)
 Function: 	Adds a new entry to the filter list for drawable features 
 Returns : 	nothing
 Args    : 	fullname - the full name to be displayed in the legend (e.g. rRNA genes)
 			pattern - regular expression determining the names of features to be
 			sorted into this class
 			color - anonymous array reference to a list of RGB values
 			type - regular expression describing the type (primary tag) of the feature
 			drawflag - should be set to 1 if the feature is to be displayed on the map

=cut

sub addDrawableFeature
{
    my ($self, %args) = @_;
    &_check_args(\%args, 'fullname', 'pattern', 'color', 'type', 'drawflag');
    push @{$self->{'_drawableFeatures'}}, {
        type    => $args{type},
        pattern => $args{'pattern'},
        color   => $args{'color'},   #das muss als anonyme ref übergeben werden
        fullname => $args{'fullname'},
        drawflag => $args{'drawflag'}
                                          };
}

=head2 getDrawableFeatures

 Title   : getDrawableFeatures
 Usage   : $map->getDrawableFeatures()
 Function: 	Returns the data structure containing the drawable feature filters
 Returns : 	an array of anomymous hash references
 Args    : 	none

=cut

sub getDrawableFeatures
{
    my $self = shift;
    my (@fList, $c);
    $c = 0;
    return @{$self->{'_drawableFeatures'}};
}

=head2 setDrawFlag

 Title   : setDrawFlag
 Usage   : $map->setDrawFlag(featureID => 'rRNA genes', drawflag => 0)
 Function: 	Manipulates the drawflag of a certain feature class. The class has
 			to specified by its fullname
 Returns : 	nothing
 Args    : 	featureID - fullname of the feature class to be manipulated
 			drawflag - 1|0

=cut

sub setDrawFlag 
{
    my ($self, %args) = @_;
    &_check_args(\%args, 'featureID', 'drawflag');
    for (my $c = 0 ; $c <= $#{$self->{'_drawableFeatures'}} ; $c++)
    {
        if (${$self->{'_drawableFeatures'}}[$c]->{'fullname'} eq $args{featureID})
        {
            ${$self->{'_drawableFeatures'}}[$c]->{'drawflag'} = $args{drawflag};
        }    # end if
    }    #end for

}

=head2 getGCcontent

 Title   : calcGCcontent
 Usage   : $map->calcGCcontent()
 Function: 	Calculates the overall GC content of the sequence
 Returns : 	GC content in per cent
 Args    : 	none

=cut

sub getGCcontent
{
    my $self    = shift;
    my $sequenz = $self->{_seqobj}->seq();
    my @hits    = $sequenz =~ /(g|c)/gi;
    return ((scalar @hits / length($sequenz)) * 100);
}

=head2 writeFeatureList

 Title   : writeFeatureList
 Usage   : $map->writeFeatureList(file => 'foo' )
 Function: 	dumps the list of sequence features to a file
 Returns : 	nothing
 Args    : 	path to file 

=cut

sub writeFeatureList
{
    my ($self, %args) = @_;
    &_check_args(\%args, 'file');
    open FILE, ">$args{file}" or croak("could not open $args{file}: $!");
    foreach my $record (@{$self->{_featureList}})
    {
        for my $key (sort keys %$record)
        {
            print FILE "$key : $record->{$key}\n";
        }
        print FILE "\n";
    }
    close FILE;
	print "wrote featurelist to file: $args{file}\n";
}

=head2 writeDrawableFeatures

 Title   : writeDrawableFeatures
 Usage   : $map->writeDrawableFeatures(file => 'foo' )
 Function: 	dumps the DrawableFeatures to a XML file
 Returns : 	nothing
 Args    : 	path to file 

=cut


sub writeDrawableFeatures
{
	my ($self, %args) = @_;
    &_check_args(\%args, 'file');
    
    my $gen = XML::Generator->new(':pretty');
    
    open FILE, ">$args{file}" or die "could not open $args{file}: $!";
    print FILE "<!-- OGDraw configuration file -->\n\n";
    print FILE "<config>\n";
    foreach my $record (@{$self->{_drawableFeatures}})	
    {
    	last if (!defined($record));
    	print FILE $gen->feature(
                            $gen->color(join(",",@{$record->{color}})),
                            $gen->fullname($record->{fullname}),
                            $gen->drawflag($record->{drawflag}),
                            $gen->pattern($record->{pattern}),
                            $gen->type($record->{type})
                            ),
                            "\n\n";
    }
    print FILE "</config>";
    close FILE;
	print "wrote drawable features to file: $args{file}\n";
}
=head2 readDrawableFeatures

 Title   : readDrawableFeatures
 Usage   : $map->readDrawableFeatures(file => 'foo' )
 Function: 	read in a custom drawable feature list from an XML file 
 Returns : 	nothing
 Args    : 	path to file 

=cut

sub readDrawableFeatures
{
    my ($self, %args) = @_;
    my ($dflist, %hash);
    &_check_args(\%args, 'file');
    
    #flush drawable feature list
    @{$self->{_drawableFeatures}} = ();
    my $f;
    eval 
    {
    	$f = XMLin($args{file});
	};
	if ($@) {
		print "<em>FATAL ERROR: XML configuration file is corrupted: $@</em>";
		exit(1);
	}
	
	# check if theres only one feature class
	my @features;
	eval {
		@features = @{$f->{feature}};
	}; if ($@) {
#		print STDERR "EXCEPTION CAUGHT: $@ .... continuing\n";
#		print STDERR "DUMPER:\n".Dumper($f);
#		print STDERR "F: $f\n";
		@features = $f->{feature};
	};
	
	foreach my $feat (@features)
	{
		my ($r, $g, $b) = split /,/, $feat->{color};
		#print "colors: $r, $g, $b\n";
		push @{$self->{_drawableFeatures}}, ({
    											'type' 		=> $feat->{type},
    											'color'		=> [$r, $g, $b],
    											'fullname'	=> $feat->{fullname},
    											'pattern'	=> $feat->{pattern},
    											'drawflag'	=> $feat->{drawflag}
    										});
	}
	#print Dumper(@{$self->{_drawableFeatures}});
}

=head2 labelsOK

 Title   : labelsOK
 Usage   : $map->labelsOK()
 Function: 	Check for long labels names that will mess up the graphical output
 Returns : 	true if all labels are shorter than MAX_LABEL_LENGTH 
 			false (undef()) if there are longer labels
 Args    : 	none 

=cut

sub labelsOK
{
    my ($self) = shift;
    foreach my $feat (@{$self->{'_featureList'}})
    {
        return FALSE if (length($feat->{'name'}) >= MAX_LABEL_LENGTH);
    }
    return TRUE;
}

=head2 setTidy

 Title   : setTidy
 Usage   : $map->setTidy(1|0)
 Function: 	Switch the tidy function on an off. Tidy will try to reformat the names of some genes classes
            and also eliminates features that are longer than MAX_GENE_SIZE
 Returns : 	nothing
 Args    : 	none 

=cut

sub setTidy
{
    # this routine modifies a package global!
    my ($self, $new_state) = @_;
    if ($new_state == 1)
    {
        $self->{_TIDY} = TRUE;
    } elsif ($new_state == 0) {
        $self->{_TIDY} = FALSE
    } else {
        print "Wrong value passed. Tidy state can be 1 or 0.\n";
    }
}

=head2 addRestrictionSites

 Title   : addRestrictionSites
 Usage   : $map->addRestrictionSites('BamHI', 'EcoRI')
 Function: 	Include the specified restriction sites in the map
 Returns : 	nothing
 Args    : 	a list of restriction enzyme names 

=cut

sub addRestrictionSites
{
    my ($self) = shift;
    my @enzymes = @_; # enzymes should be passed as clear names like "BamHI"
        
    my $analysis = Bio::Restriction::Analysis->new(-seq => $self->{'_seqobj'});
#     my $enz_collection = $analysis->enzymes();
    my $lars_favorite_bullshit_enzyme = new Bio::Restriction::Enzyme(-enzyme=>'SapI', -seq=>'GCTCTTCN^NNN');
    $analysis->enzymes($lars_favorite_bullshit_enzyme);
    
    my $RE_report = "-----------------------------------<br>";
    $RE_report .= "Restriction analysis of ".$self->{_seqobj}->desc()."<br>";
    $RE_report .= "Enzymes:<br> ".print_in_html_columns(4,@enzymes)."<br>";
    
    foreach my $enzyme (@enzymes)
    {
        my $cuts = $analysis->cuts_by_enzyme($enzyme);
        my @positions = $analysis->positions($enzyme);
        
        $RE_report .= "<br><div class=\"enzyme\">$enzyme cuts $cuts times. </div>Positions:<br>".print_in_html_columns(6,@positions)."<br>"
            if ($cuts > 0);
        
        foreach my $cut_site (@positions)
        {
        	my $site_position = (360 / (length($self->{_seqobj}->seq()))) * $cut_site;
        	my $string_x = cos($site_position / 360 * 2 * PI) * $RE_LABEL_RADIUS;    #umrechnung  in rad * radius der Beschriftung
	        my $string_y = sin($site_position / 360 * 2 * PI) * $RE_LABEL_RADIUS;
	        my $shift_x = sin($site_position / 360 * 2 * PI) * LABEL_SHIFT; 
	        my $shift_y = cos($site_position / 360 * 2 * PI) * LABEL_SHIFT;
	        
	        my $site_name = $enzyme." ($cut_site)";
	        
	        my $boundaries = GeneMap::Plastome::BoundingBox->new	(
        											'x' 		=>(CENTER_X + $string_x + $shift_x),
        											'y' 		=>(CENTER_Y + $string_y - $shift_y),
        											width 	=> CHAR_WIDTH * length($site_name),
        											height 	=> CHAR_HEIGHT # height of bouding box
        											);
        											
            # add an entry to _restrictionSites for each site found
            push @{$self->{_restrictionSites}}, 
            (
                {
                'name'      	=> $site_name,
                'position'     	=> $site_position,
                'label_position'=> $site_position,
                'label_box'		=> $boundaries
                }
            );
        }
    }
    
    # sort REs ascending according to their position in the plastome 
    @{$self->{_restrictionSites}} = sort { $a->{'position'} <=> $b->{'position'} } @{$self->{_restrictionSites}};
    
    # check if labels do overlap and move them apart 
    # until all labels don't show overlapping any more
    my $found_collision = TRUE;
    my $loop_counter = 0;
    while (TRUE) 
    {
		$found_collision = FALSE;
		for (my $c = 0; $c <= ($#{$self->{_restrictionSites}} - 1); $c++)
		{
			
			if (${$self->{_restrictionSites}}[$c]->{label_box}->collides_with(${$self->{_restrictionSites}}[$c+1]->{label_box}))
			{
                $found_collision = TRUE;
                _shift_RE_labels(
                                    \${$self->{_restrictionSites}}[$c],
                                    \${$self->{_restrictionSites}}[$c+1],
                                    360 / $self->{_seqobj}->length() #  stepwidth for one shift
                                );
            }
		}
		$loop_counter++;
        last if ($found_collision == FALSE || $loop_counter > 50);
	}
	return $RE_report;
}

=head2 is_circular

 Title   : is_circular
 Usage   : $map->is_circular
 Function: 	Returns true if the sequence is cirular. This is actually a "loop-through" of the Bio::Seq function 
 Returns : 	Boolean value
 Args    : 	none

=cut

sub is_circular
{
	my $self = shift;
	if ($self->{_seqobj}->is_circular)
	{
		return TRUE;
	} else {
		return FALSE;
	}
}

###############################################################
#                INTERNAL CLASS SUBROUTINES                   #
###############################################################


sub _shift_RE_labels
{
	# the values are passed by ref so the original values will be modified
	my ($p_re1, $p_re2, $shift) = @_;
	$shift = $shift * 10;my $pos = ($$p_re2->{label_position} + $$p_re1->{label_position}) / 2; # position of overlapping pair
	
	if (($pos >= 315 && $pos <= 45) || ($pos >= 135 && $pos <= 225))
	{
		# right and left side of circle
    	$$p_re1->{label_position} -= $shift;
    	$$p_re2->{label_position} += $shift;
    	
    	# re-compute the label coordinates
    	$$p_re1->{label_box}->setX(CENTER_X + cos(($$p_re1->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re1->{label_box}->setY(CENTER_Y + sin(($$p_re1->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re2->{label_box}->setX(CENTER_X + cos(($$p_re2->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re2->{label_box}->setY(CENTER_Y + sin(($$p_re2->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		
	} elsif (($pos >= 90 && $pos <= 135) || ($pos >= 270 && $pos <= 315)) {
		# upper and lower half
    	$$p_re1->{label_position} -= $shift;
    	$$p_re2->{label_position} += $shift;
    	
		$$p_re1->{label_box}->setX(CENTER_X + cos(($$p_re1->{label_position}) / 360 * 2 * PI) * ($RE_LABEL_RADIUS + 10));
		$$p_re1->{label_box}->setY(CENTER_Y + sin(($$p_re1->{label_position}) / 360 * 2 * PI) * ($RE_LABEL_RADIUS + 10));
		$$p_re2->{label_box}->setX(CENTER_X + cos(($$p_re2->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re2->{label_box}->setY(CENTER_Y + sin(($$p_re2->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
	} else {
        # upper and lower half
    	$$p_re1->{label_position} -= $shift;
    	$$p_re2->{label_position} += $shift;
    	
		$$p_re1->{label_box}->setX(CENTER_X + cos(($$p_re1->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re1->{label_box}->setY(CENTER_Y + sin(($$p_re1->{label_position}) / 360 * 2 * PI) * $RE_LABEL_RADIUS);
		$$p_re2->{label_box}->setX(CENTER_X + cos(($$p_re2->{label_position}) / 360 * 2 * PI) * ($RE_LABEL_RADIUS + 10));
		$$p_re2->{label_box}->setY(CENTER_Y + sin(($$p_re2->{label_position}) / 360 * 2 * PI) * ($RE_LABEL_RADIUS + 10));
	
	}
}

sub _guess_organelle
{
    my $desc = shift;
    
   
    if ($desc =~ /chloropla|plastid/gi)
    {
        return 'chloroplast';
    } elsif ($desc =~ /mitochond/gi) {
        return 'mitochondrial';
    } elsif ($desc =~ /kinetoplas/gi) {
    	return 'kinetoplast';
    } else {
    return FALSE
    }
}

sub _read_contents
{
    shift; #discard class
    my $seqobj = shift;
    my (@unsorted_featurelist, @featurelist, @found_types);
    my $feat_name = '';
    my $c         = 0;
    my @feats     = $seqobj->get_SeqFeatures();
    my $counter   = 0;
    my %seen_trnas; 
    my (@found_operons, @large_split_locations);
    
        
    # process split locations and add a new feature
    # for each sublocation
    foreach my $feat (@feats)
    {
        # extract the name from the feature
        my $feat_name = _extract_feature_name($feat);
        my $feat_size = abs($feat->end() - $feat->start());
        
        
        # find polycistronic transcripts
        if (($feat->primary_tag() =~ /prim_transcript|mrna/i) ) #&& ($feat_name !~ /rrn/i)
        {
            
            
            #print "prim_transcript: $feat_name-->".$feat->start()."..".$feat->end()."\n";
            foreach my $f (@feats)
            {
                if 	(	($f->start >= $feat->start) and 
                        ($f->end <= $feat->end) and 
                        ($feat_name ne _extract_feature_name($f)) and 
                        ($f->primary_tag() =~ /gene|trna|cds/i) and
                        ($f->strand() == $feat->strand())	)
                {
                    #print "\tis polycistronic, contains: "._extract_feature_name($f)." ".$f->primary_tag()."\n"; 
                    my $operon = Bio::SeqFeature::Generic->new(
                                        -primary        => '_operon_', # our selfmade type
                                        -start          => $feat->start,
                                        -end            => $feat->end
                                        );
                    $seqobj->add_SeqFeature($operon);
                    push @found_operons, $feat;
                    last;                    
                } 							
            }
        }
        
            
        # store all tRNA names in a hash 
        # later we use this hash to exclude trnas
        # that are annotated as 'tRNA' and 'gene'
        $seen_trnas{$feat_name} = 1 if ($feat->primary_tag() =~ /trna/i);
        
        
		# check if it is a split location and process in accordingly
        # we also need to check for absurdely large features here because some
        # of them are annotated as split locations
        if ( $feat->location->isa('Bio::Location::SplitLocationI') && ($feat_size > MIN_SPLIT_SIZE))  
        {
            # proceed without doing anything if all the split locations 
            # lie within the root location
            # this doesn't seem to work as genes that are distributed across the whole
            # maize Chondriome are not drawn anymore - deactivated it
#             if ($feat->location->is_single_sequence()) 
#             {
#                 #print "Location object ".$feat_name.":".$feat->start()."..".$feat->end()." is split but only across a single sequence<br>";
#                 # do not generate sublocation features
#                 #next;
#             }
           
           foreach my $loc ( $feat->location->sub_Location ) 
           {
                # the sublocations are all typed genes....
                my $sub_type = 'gene';
                #print "--->".$loc->strand()."<br>" if ($feat_name =~ /nad5/i);
                my $sub_feat = Bio::SeqFeature::Generic->new(
                                        -tag           => {$sub_type => $feat_name},
                                        -primary        => $feat->primary_tag(), #type
                                        -strand         => $loc->strand(),
                                        -start          => $loc->start,
                                        -end            => $loc->end
                                        );
                # add sublocation to seqobj annotation
                $seqobj->add_SeqFeature($sub_feat);
             
           }# foreach loc
           
           push @large_split_locations, $feat;
        }
    }
    
    # but how do we get rid of the old feature?
    # it has to be deleted otherwise we still draw the long features....
    # we (seem to be able to) do it like this:
    
    # this should flush all features from the seqobj
    my @feat_array = $seqobj->remove_SeqFeatures();
    
    
    my $e=0;
    while (defined($feat_array[$e]))
    {
        
        # deactivated drawing for polycistronic genes (i.e. operons) unless they
        # are only annotated once
        $feat_array[$e]->primary_tag('nicht_malen') if ((_is_polycistronic_gene($feat_array[$e], @found_operons)) && 
                                                        (!_is_singular_gene_feature($feat_array[$e], @feats)));
        
        # remove unsplit split location features
        splice(@feat_array, $e, 1) if (is_same_feature($feat_array[$e], @large_split_locations));
        $e++;
    }
    
    # and add features back to the seqobj
    my $r = $seqobj->add_SeqFeature(@feat_array);
    
    # the next round has to read in the features again, other- 
    # wise we will not see the changes
    @feats     = $seqobj->get_SeqFeatures();
   
    foreach my $feature (@feats)
    {
        my $feat_start  = ($feature->start() / $seqobj->length()) * 360;
        my $feat_extent = ($feature->end() / $seqobj->length()) * 360;
        my $feat_strand = $feature->strand();
        my $feat_type   = $feature->primary_tag();
        my $feat_name   = _extract_feature_name($feature);
        my $feat_size = abs($feature->end() - $feature->start());
        
        # nobody needs the source feature. do you?
        next if ($feat_type eq "source");
        
        next if (!defined($feat_strand));
        
        # exclude tRNA genes that are already annotated as tRNA type features
        if (($feat_type =~ /gene/i) && (exists($seen_trnas{$feat_name})))
        {
        	next;
        }
        
        # save the type in @found_types 
        push @found_types, $feat_type;   
        
        # we store all features that do not have an absurd size...
        push @unsorted_featurelist,
          (
            {
             'name'      		=> $feat_name,
             'start'     		=> $feat_start,
             'extent'    		=> $feat_extent,
             'type'      		=> $feat_type,
             'strand'    		=> $feat_strand,
             'labelAngle'		=> (($feat_start + $feat_extent) / 2),
             'optimizedAngle' 	=> undef(),
             'contains_others' 	=> undef(),
             'ID' 				=> $counter
             
            }
          );# unless ($feat_size > MAX_GENE_SIZE);

        $counter++;
    }
    
    # sorts features descending according to their length
    # this is necessary to prevent large features from covering smaller overlapping ones
    @featurelist =
      sort { $b->{'labelAngle'} <=> $a->{'labelAngle'} }
      @unsorted_featurelist;         

    my @drawable_types = &_unique(@found_types);
   
    return (\@featurelist, \@drawable_types);
}# end sub _read_contents




sub _is_singular_gene_feature
{
    my $feature = shift;
#    print "Kuckuck - da bin ich \n";
    my $feature_name = _extract_feature_name($feature);
    my @feats = @_;
    foreach my $f (@feats)
    {
        if (($f->start != $feature->start) &&
            ($f->end != $feature->end) &&
            ($f->primary_tag eq 'gene') &&
            ($feature_name eq _extract_feature_name($f)))
        {
            #print "$feature_name is not a singular gene\n";
            return FALSE;
        }
    }
    return TRUE;
}

sub _is_polycistronic_gene
{
    my $test = shift; 
    my @operons  = @_;
    foreach my $o (@operons)
    {
        if (($o->start == $test->start) &&
            ($o->end == $test->end) &&
            ($test->primary_tag ne '_operon_'))
        {
            return TRUE;
        }
    }
    return FALSE;
}

sub _extract_feature_name
{

	 my $feat = shift;
 
	 my $feat_name;
#      my @tags = $feat->get_all_tags();
     
     if (($feat->primary_tag() eq "CDS") and ($feat->has_tag('note')) and ($feat->has_tag('gene')))
     {
#      	print "vielleicht ORF<br>";
     	my @notes = $feat->get_tag_values('note');
     	foreach my $note (@notes) 
     	{
#      		print $note."<br>";
     		if ($note =~ /(^orf\s*\d+.*)/i) 
     		{
#      			print $&."<br>";
     			return $note
     		};     		
     	}
     }
     
     if ($feat->has_tag('gene'))
     {
         my @names = $feat->get_tag_values('gene');
         foreach my $name (@names) { $feat_name = $name }
     }
     elsif ($feat->has_tag('label'))
     {
         my @notes = $feat->get_tag_values('label');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('note'))
     {
         my @notes = $feat->get_tag_values('note');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('locus_tag'))
     {
         my @notes = $feat->get_tag_values('locus_tag');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('product'))
     {
         my @notes = $feat->get_tag_values('product');
         foreach my $note (@notes) { $feat_name = $note }

     }
     else
     {
         $feat_name = 'N/D';
     }
     return $feat_name;
}

sub _preprocess_feature_list
{
    my $self = shift;
    my @seen_angles;
    
    # here we have to check whether the feature is a gene that is not covered by the 
    # drawable features list and then define type as other. problem is that all tRNAs
    # and rRNAs seem to meet these conditions because they are also annotated as genes
    # and we only filter for type 'tRNA' resp. type 'rRNA' entries. We need a means to
    # see whether a feature is already on the map....
    
    # save the label angles of all drawable features that will appear on the map
    for (my $c = 0; $c <= $#{$self->{_featureList}}; $c++)
    {
        push @seen_angles, ${$self->{_featureList}}[$c]->{labelAngle} 
            if (_is_drawable_feature($self, ${$self->{_featureList}}[$c], FALSE));
    }
    
    for (my $c = 0; $c <= $#{$self->{_featureList}}; $c++)
    {
        # is the feature a gene that is not drawable and not
        # at the same angle position as one of the drawable features?
        # if yes tag it 'other' << problem the ones that are already tagged other
        # will be drawable features ...... but it seems to work, anyway.
        if (!_is_default_drawable_feature($self, ${$self->{_featureList}}[$c], FALSE) 
                && 
            (${$self->{_featureList}}[$c]->{type} eq 'gene')
            	&& 
            (${$self->{_featureList}}[$c]->{name} !~ /(^rrn.*)|(^rn.*)/i)
                &&
             (!_is_element_of(${$self->{_featureList}}[$c]->{labelAngle}, @seen_angles )) )
            
        {
             ${$self->{_featureList}}[$c]->{type} = 'other';
        }
    }
    
 
} # end _preprocess_feature_list


sub _contains
{
	my ($test, $feat) = @_;
	if ( ($feat->{'start'} >= $test->{'start'}) && 
	     ($feat->{'end'} <= $test->{'end'}) &&
	     ($feat->{'type'} ne 'intron') ) {
	     		
	     print $test->{'name'}." contains ".$feat->{'name'}."<br>";
	     return TRUE;
	}
	return FALSE;
}

#####################
# CLEAN-UP ROUTINES #
#####################


sub _clean_up_labels
{

    my $self        = shift;
    #sort { $b->{'labelAngle'} <=> $a->{'labelAngle'} } @{$self->{_featureList}};#HERE  NOT GOOD?!
    my @local_flist = @{$self->{_featureList}}; # local copy of the featurelist
    my (@insideLabels, @outsideLabels);			# arrays holding the labels and angles
	
	#initialize label lists - there's probably a smarter way but this one works, too
	foreach my $e (@local_flist)
	{
		# exclude introns from the label list - they are not labeled
		next if ($e->{type} eq 'intron');
		if (($e->{strand} == 1) and (_is_drawable_feature($self, $e)))
		{
			push @outsideLabels, 	{
						'name'  => $e->{name},
						'angle' => $e->{labelAngle},    # winkelposition des labels vor optimierung
						'ID' => $e->{ID} #ID des Features zur Identifizierung
						};
			last; 
		}
	}
	
	foreach my $e (@local_flist)
	{
		# exclude introns from the label list - they are not labeled
		next if ($e->{type} eq 'intron');
		if ($e->{strand} == -1 and (_is_drawable_feature($self, $e)))
		{
			push @insideLabels, 	{
						'name'  => $e->{name},
						'angle' => $e->{labelAngle},    # winkelposition des labels vor optimierung
						'ID' => $e->{ID} #ID des Features zur Identifizierung
						};
			last; 
		}
	}
	
	#print ">".scalar(@outsideLabels)."<----->".scalar(@insideLabels);exit;

 	# fill label lists with life
 	#hier muss unbedingt gecheckt werden, ob wir hier nicht labels rausschmeißen, die eigentlich nicht entsorgt werden sollten.
	for (my $c = 1; $c <= $#local_flist; $c++)
    {
        
        # here we check whether the angle of the previous feature is the same 
        # the current one - is that really necessary? 
        # 
        
        # exclude introns and operons from the label list - they are not labeled
		next if (($local_flist[$c]->{type} eq 'intron') || ($local_flist[$c]->{type} eq '_operon_')); 
		
        if ((scalar(@outsideLabels) >= 1) && ($local_flist[$c]->{strand} == 1)  &&  (($outsideLabels[-1]->{angle}) ne $local_flist[$c]->{labelAngle})   )
		{
			for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
			{
				if (_is_drawable_feature($self, $local_flist[$c])) 
				{
				
				push @outsideLabels, {
            							'name'  => $local_flist[$c]->{name},
            							'angle' => $local_flist[$c]->{labelAngle},    # winkelposition des labels vor optimierung
            							'ID' => $local_flist[$c]->{ID} #ID des Features zur Identifizierung
        							};
				last;
				}		 
			}
		} 

        if ((scalar(@insideLabels) >= 1) && ($local_flist[$c]->{strand} == -1)  && (($insideLabels[-1]->{angle}) ne $local_flist[$c]->{labelAngle})  ) 
				
		{
			for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
			{
				if (_is_drawable_feature($self, $local_flist[$c])) 
				{
				
				push @insideLabels, {
            							'name'   => $local_flist[$c]->{name},
            							'angle'  => $local_flist[$c]->{labelAngle},    # winkelposition des labels vor optimierung
            							'ID'     => $local_flist[$c]->{ID} #ID des Features zur Identifizierung
        							};
				last;
				}		 
			}
		} 
    }
    
    # sort arrays according to angle positions decreasing
#     sort { $a->{'angle'} <=> $b->{'angle'} } @insideLabels;
#     sort { $a->{'angle'} <=> $b->{'angle'} } @outsideLabels;
#     
	# these variables have to be valid outside of the following loop
	my (
		$p_outside_starts, 
		$p_outside_ends, 
		$p_outside_clusters, 
		$found_flag,
		$p_inside_starts, 
		$p_inside_ends, 
		$p_inside_clusters,
		$p_comb_outside_clusters,
		$p_comb_inside_clusters,
		);
		my $counter = 0;
		 
	# execute the cluster finding / angle recalculation
	# procedure until no more clusters are found 
	while (TRUE)
	{
		
		# find the clusters
		($p_outside_starts, $p_outside_ends, $p_outside_clusters, $found_flag) = &_identify_clusters (MIN_OUTER, @outsideLabels);
		($p_inside_starts, $p_inside_ends, $p_inside_clusters, $found_flag) = &_identify_clusters (MIN_INNER, @insideLabels);
		
        # BAD STYLE.
		BYPASS:
		#print "---------------> FOUND STH\n" if ($found_flag);
		
		# exit while loop if there were no more new clusters found 
  	  	# or the whole procedure was executed MAX_OPT_RUNS times
		last if ((!defined($found_flag)) or ($counter == MAX_OPT_RUNS));
		
		# combine overlapping clusters
		$p_comb_outside_clusters = _combine_overlapping($p_outside_clusters);
		$p_comb_inside_clusters = _combine_overlapping($p_inside_clusters);
		
	  	# recalculate the angles
	  	_recalculate_angles($self, $p_comb_outside_clusters, MIN_OPT_OUTER, \@outsideLabels);
	  	_recalculate_angles($self, $p_comb_inside_clusters, MIN_OPT_INNER, \@insideLabels);
	  	
	  	
	  	
	  	# second round : Are there any new clusters due to the shifting of the labels?
	  	($p_outside_starts, $p_outside_ends, $p_outside_clusters, $found_flag) = &_identify_clusters (MIN_OPT_OUTER, @outsideLabels);
		($p_inside_starts, $p_inside_ends, $p_inside_clusters, $found_flag) = &_identify_clusters (MIN_OPT_INNER, @insideLabels);
		
	
  	  	
  	  	#print "\n-------------------------------COUNTER $counter\n\n";
	  	$counter++;
	  	goto BYPASS;
  	}#end while(TRUE)
}# end sub

sub _recalculate_angles
{
	my (
		$self,
		$p_clusters,
		$minimal_angle,
		$p_labels
		) = @_;
		
	
	foreach my $cluster (@{$p_clusters})
	{
# 			print "start: ".$cluster->{start}."\tend: ".$cluster->{end}."\n";
        my @cluster_range;

        for (my $c=$cluster->{start}; $c <= $cluster->{end}; $c++) # in cluster you find the start and end-indexposition of clusters in outsideLabels which contains ID name and angle
        {
# 	            print $outsideLabels[$c]->{name}.":".$outsideLabels[$c]->{ID}." ";
            for (my $d = 0; $d <= $#{$self->{_featureList}}; $d++)
            {
                if (${$self->{_featureList}}[$d]->{ID} == @{$p_labels}[$c]->{ID}) # find the gene in _feat_list by ID which was identified as lying in a cluster by outsidelabels and cluster
                {
                    unshift @cluster_range,    ({
                                                'ID'    => ${$self->{_featureList}}[$d]->{ID},
                                                'angle' => ${$self->{_featureList}}[$d]->{optimizedAngle}
                                                                     ||
                                                           ${$self->{_featureList}}[$d]->{labelAngle}             
                                            }); # produce an array which contains all genes in a cluster
                }
            }
           
            
                                                
        }

        # now we calculate the optimized angles for each label in a cluster.....
# 	        print "[0]:".$cluster_range[0]->{angle}." [-1]:".$cluster_range[-1]->{angle}."";

        
        
        my $cluster_center = ($cluster_range[-1]->{angle} + $cluster_range[0]->{angle}) / 2;
        my $cluster_label_count = $#cluster_range;
# 	        print "\n";

        my $cluster_required_space = $cluster_label_count * ($minimal_angle);
        my $cluster_new_start = $cluster_center - ($cluster_required_space / 2); 
        
        #print "Outsideclusters: Center = $cluster_center°; Number of labels: $cluster_label_count\nReq_space: $cluster_required_space\nold_start: ".$cluster_range[0]->{angle}." new_start: $cluster_new_start old_cluster_end: ".$cluster_range[-1]->{angle}."\n//\n";
        # .... and write them to _featureList
        for (my $c = 0; $c <= $cluster_label_count; ++$c)
        {
            for (my $d = 0; $d <= $#{$self->{_featureList}}; $d++)
            {
                if (${$self->{_featureList}}[$d]->{ID} == $cluster_range[$c]->{ID})
                {
                    # write new key optimizedAngle to _featureList
                    ${$self->{_featureList}}[$d]->{optimizedAngle} = $cluster_new_start + $c * ($minimal_angle);
                }
            }
            
            # die winkel mssen auch in $outsideLabels[$c]->{ID} eingetragen werden
            # sonst luft die while schleife ewig weiter
            
                      
            for (my $d = 0; $d <= $#{$p_labels}; $d++)
            {
                if (${$p_labels}[$d]->{ID} == $cluster_range[$c]->{ID})
                { 
                    ${$p_labels}[$d]->{angle} = $cluster_new_start + $c * ($minimal_angle);
                    #print "-$c:".${$p_labels}[$d]->{name}."\t@:".${$p_labels}[$d]->{angle};
                    ${$p_labels}[$d]->{is_optimized} = TRUE;
                }
            }
            #print "\n";
        }
	} # end foreach
	
	# remove all elements that do not cluster from the labellist 
	my $e=0;
	while (defined(${$p_labels}[$e]))
	{
	   if (!(${$p_labels}[$e]->{is_optimized}))
	   {
	       # remove non-clustering element
	       splice(@{$p_labels}, $e, 1);
	   }
	   ++$e;
	}

}

sub _identify_clusters # nice name for nice algorithm
{
	my $factor = shift;
    my @labelArray = @_; # list of labels to be processed
    my $end = $#labelArray;
	my (
		@startpos, # array for storage of cluster start positionsexit
        @endpos,   # array for storage of cluster end positions
        $range_sum, # sum of angles in current range
        $range_labels,  # number of labels in current range
        @clusters, # array (of hashes) for storage of cluster positions
        $_found_cluster, # boolean Flag to tell the calling sub that min 1 cluster was found 
        );
    $_found_cluster = FALSE;   
    
 
    for (my $start_index = 0 ; $start_index <= $#labelArray ; $start_index++)
    {
        #print "-->startindex: $start_index\n";
        for (my $end_index = $end ; $end_index >= $start_index ; $end_index--) 
        {	
			#print $end_index;
            $range_sum = $labelArray[$start_index]->{angle} - $labelArray[$end_index]->{angle};
            my $required_space = ($end_index - $start_index) * $factor;
            if ($range_sum < $required_space) #1,8° je Beschriftung 
            {
                $_found_cluster = TRUE;
                my ($startcount, $offset);
                $offset     = $end_index - $start_index;
                $startcount = $start_index;
                #print "\n\n//CLUSTER//\n>|$startcount|\t|$offset|\n//\n\n";
                push @startpos, $startcount;
                push @clusters, 
                {	
                	'start' 	=> $startcount, 
                	'startID'		=> $labelArray[$startcount]->{ID},
                	'end' 	=> $startcount + $offset, 
                	'endID' 		=> $labelArray[($startcount+$offset)]->{ID}
                };
                push @endpos,   $startcount + $offset;
                $start_index = $end_index; #jump over cluster; start again with finding
                last;
            }    #end if
        } 
       #end for2
    }    #end for1
    
    return \@startpos, \@endpos, \@clusters, $_found_cluster;
}

sub _combine_overlapping
{
	my $p_clusters = shift; 
	my @clusters = @{$p_clusters};
	# combine overlapping clusters
	my @comb_clusters = @clusters; # need to make a copy otherwise iteration crashes
	for (my $d = 0 ; $d < $#clusters ; $d++)
	{
	    if (
	        (
        
       
	         _is_element_of(
	                        $clusters[$d + 1]->{start},
	                        $clusters[$d]->{start} .. $clusters[$d]->{end}
	                       )
	        )
	        or (
	            _is_element_of(
	                           $clusters[$d + 1]->{end},
	                           $clusters[$d]->{start} .. $clusters[$d]->{end}
	                          )
	           )
	       )
	    {
	        #print "OVERLAP between cluster#$d and #" . ($d + 1) . "\n";
	        my $comb_start = $clusters[$d]->{start}; # set start of combined cluster to start of left overlapping cluster
            my $startID = $clusters[$d]->{startID};
	        my $comb_end =   $clusters[$d + 1]->{end}; # set end of combined cluster to end of right overlapping cluster
            my $endID = $clusters[$d+1]->{endID};
	        splice(@comb_clusters, $d, 2)
	          ;        # remove the two overlapping clusters from the list....
	        unshift @comb_clusters, ({
                                        "start"     => $comb_start,
                                        "startID"   => $startID,
                                        "end"       => $comb_end,
                                        "startID"   => $endID
                                    });    # ...and add the combined cluster to the biginning of the list.
	    }    #end if

	}    #end for
 	return \@comb_clusters;
}

####################
# DRAWING ROUTINES #
####################

sub _create_graph
{
    my $self   = shift;
    my $shiftSSC = shift;
    my $fullLegend = shift; 
    #create PostScript object
    my $plastome_ps = new PostScript::Simple(
                                     colour => 1,      
                                     eps    => 0,
                                     units  => "bp",
                                     xsize  => PS_X_SIZE,
                                     ysize  => PS_Y_SIZE
                                            );
    $plastome_ps->newpage;
    $plastome_ps->setfont("Helvetica", 10);

    my $mapname = $self->{_displayName}; #next 9 lines are needed for drawing Name and Length of Plastome at the end of this sub
    $mapname =~ s/\.//; #delete . in filename
    $mapname =~ s/\s\S*,\s.*//;

    # stores all angles that have already been drawn
    my @seen_angles; 
    
    # now insert the restriction sites, if they were specified
    _draw_restriction_sites($self, $plastome_ps) if (scalar(@{$self->{_restrictionSites}}) > 0);
    
    # iterate over featurelist and draw all features plus labels
    foreach my $ff (@{$self->{_featureList}})
    {
        # a reference to this variable
        # will be passed to the _is_drawable_feature sub
        # later - to pass back the color of the feature
        my $draw_color;
        
        # don't draw features with same angle twice
        if (_is_element_of($ff->{labelAngle}, @seen_angles))
        {
           next;
        }
        
        # try and replace common annotation mistakes to unify the output
        # and ignore genes that are absurdly large and do probably result 
        # from annotation errors
        my $feat_name = $ff->{'name'}; 
        if ($self->{'_TIDY'})
        {
            my $feat_size = abs(($ff->{'extent'} - $ff->{'start'}) * ($self->{_seqobj}->length() / 360));
            next if ($feat_size > MAX_GENE_SIZE);
            $feat_name = _tidy_up_name($feat_name) if ($self->{_TIDY});
        }
        
        # draw everything that is a drawable feature
		if (_is_drawable_feature($self, $ff, \$draw_color))
        {
            # operons will be drawn later
            next if ($ff->{type} eq '_operon_'); 
            
            no warnings;
            
            if ($ff->{'strand'} == 1)
            {
                &_draw_outside_feature($plastome_ps, $ff->{'extent'} - $shiftSSC,
                                       $ff->{'start'}- $shiftSSC,  $draw_color, $ff->{'type'});
                &_write_outside_label($plastome_ps, $feat_name, $ff->{labelAngle} - $shiftSSC, $OUTSIDE_LABEL_RADIUS, $ff->{optimizedAngle} - $shiftSSC, $shiftSSC)
                  unless ($ff->{'type'} eq "intron");
                push @seen_angles, $ff->{labelAngle};
            }
            else
            {
                &_draw_inside_feature($plastome_ps, $ff->{'extent'} - $shiftSSC,
                                      $ff->{'start'} - $shiftSSC,  $draw_color, $ff->{'type'});
                &_write_inside_label($plastome_ps, $feat_name, $ff->{labelAngle} - $shiftSSC, $INSIDE_LABEL_RADIUS, $ff->{optimizedAngle} - $shiftSSC, $shiftSSC)
                  unless ($ff->{'type'} eq "intron");
                push @seen_angles, $ff->{labelAngle};
            }
        }
        
        use warnings;
    }    # end foreach my $ff (@featurelist)
    
    

    
    # draw the main circle
    $plastome_ps->setcolour("black");   
    $plastome_ps->setlinewidth(3);
    $plastome_ps->circle(CENTER_X, CENTER_Y, $MAIN_RADIUS);
    
    # draw polycistronic transcripts, if activated
    foreach my $ff (@{$self->{_featureList}})
    {
    	if ((_is_drawable_feature($self, $ff, FALSE)) and ($ff->{type} eq '_operon_') )
        {
            _draw_operon($plastome_ps, $ff->{start} - $shiftSSC, $ff->{extent} - $shiftSSC);
        }
    }

    # insert the name and sequence length
    $plastome_ps->setcolour("black"); 
    $plastome_ps->setfont("Helvetica-BoldOblique", 24);
    $plastome_ps->text({align => "center",}, CENTER_X, 635, "$mapname");  #main label
    $plastome_ps->setfont("Helvetica", 24);
    if ($self->{_organelle} eq "unknown") {
    	$plastome_ps->text({align => "center"}, CENTER_X, 595, $self->{_seqobj}->desc());
    } else {
    	$plastome_ps->text({align => "center"}, CENTER_X, 595, $self->{_organelle}." genome");
    }    
    $plastome_ps->setfont("Helvetica", 22);
    
    # Mohammad wants nice decimal separators......
    my @seqlen_arr = reverse (split(//, $self->{_seqobj}->length()));
    my ($seqlength, @arr);
    my $c = 0;
    foreach my $s (@seqlen_arr)#
    {
        push @arr, "," if (($c > 0) && ($c % 3 == 0));
        push @arr, $s;
        $c++;
    }
        $seqlength = reverse (join("",@arr));
    
    $plastome_ps->text({align => "center"}, CENTER_X, 555, "$seqlength bp");
    
    # insert legend
    &_draw_legend($self, $plastome_ps, $fullLegend);
    
    return $plastome_ps;
    
}    #end sub _create_graph

sub _draw_operon
{
	my ($plastome_ps, $op_start, $op_extent) = @_;
	
    $plastome_ps->setlinewidth(OPERON_WIDTH);    # Feature in Farbe
    $plastome_ps->setcolour(OPERON_COLOR);
    $plastome_ps->arc(CENTER_X, CENTER_Y, $MAIN_RADIUS, $op_start, $op_extent);
	
}

sub _draw_restriction_sites
{
    my ($self, $plastome_ps) = @_;
    
    
    foreach my $site (@{$self->{_restrictionSites}})
    { 
        
        # draw RE label
        $plastome_ps->setcolour(DARK_RED);
        if (($site->{position} <= 90) or ($site->{position} >= 270))
        {
            $plastome_ps->text(
                            ($site->{label_box}->getX()),
                            ($site->{label_box}->getY()), 
                            $site->{name}
                            )
        }    #end if
        else
        {
            $plastome_ps->text(
                            {align => "right"},
                            ($site->{label_box}->getX()),
                            ($site->{label_box}->getY()),
                            $site->{name}
                            );
        } #end else
        $plastome_ps->setcolour(RE_LINE_COLOR);
        $plastome_ps->setlinewidth(1);
        $plastome_ps->line(
		                       CENTER_X + (cos($site->{position} / 360 * 2 * PI) * $MAIN_RADIUS), # the float number is the radius of the main circle
		                       CENTER_Y + (sin($site->{position} / 360 * 2 * PI) * $MAIN_RADIUS),
		                       $site->{label_box}->getX(),
		                       $site->{label_box}->getY()
		                      );
     }
}# end sub

sub _draw_IR
{
    my ($shift_ssc, $plastome_ps, $seqobj, $IRA_start, $IRA_end, $IRB_start, $IRB_end) = @_;
    #                     where IRA start has to be LSC-IRA and IRB start LSC-IRB border

    $IRA_start = ($IRA_start / $seqobj->length()) * 360;
    $IRA_end   = ($IRA_end / $seqobj->length()) * 360;
    $IRB_start = ($IRB_start / $seqobj->length()) * 360;
    $IRB_end   = ($IRB_end / $seqobj->length()) * 360;
    
    $IRA_start -= $shift_ssc; # center SSC onto 270° (6 o'clock)
    $IRA_end -= $shift_ssc;
    $IRB_start -= $shift_ssc;
    $IRB_end -= $shift_ssc;
    
    my $IRA_start_rad = $IRA_start / 360 * 2 * PI;
    my $IRA_end_rad   = $IRA_end / 360 * 2 * PI;
    my $IRB_start_rad = $IRB_start / 360 * 2 * PI;
    my $IRB_end_rad   = $IRB_end / 360 * 2 * PI;
    #print "IRA-Start: $IRA_start, IRA-End: $IRA_end, IRB-Start: $IRB_start, IRB-End: $IRB_end \n";

    $plastome_ps->setcolour("black");
    $plastome_ps->setlinewidth(6);

    #draw IRA
    $plastome_ps->arc(CENTER_X, CENTER_Y, $MAIN_RADIUS, $IRA_start, $IRA_end);

    #draw IRB
    $plastome_ps->arc(CENTER_X, CENTER_Y, $MAIN_RADIUS, $IRB_start, $IRB_end);
    $plastome_ps->setlinewidth(3);

    #draw subcircle for IRA & IRB
    $plastome_ps->circle(CENTER_X, CENTER_Y, 250);

    #draw dashes for begin & end of IRA
    $plastome_ps->line(
                       CENTER_X + cos($IRA_start_rad) * 240,
                       CENTER_Y + sin($IRA_start_rad) * 240,
                       CENTER_X + cos($IRA_start_rad) * 260,
                       CENTER_Y + sin($IRA_start_rad) * 260
                      );
    $plastome_ps->line(
                       CENTER_X + cos($IRA_end_rad) * 240,
                       CENTER_Y + sin($IRA_end_rad) * 240,
                       CENTER_X + cos($IRA_end_rad) * 260,
                       CENTER_Y + sin($IRA_end_rad) * 260
                      );

    #draw dashes for begin & end of IRB
    $plastome_ps->line(
                       CENTER_X + cos($IRB_start_rad) * 240,
                       CENTER_Y + sin($IRB_start_rad) * 240,
                       CENTER_X + cos($IRB_start_rad) * 260,
                       CENTER_Y + sin($IRB_start_rad) * 260
                      );
    $plastome_ps->line(
                       CENTER_X + cos($IRB_end_rad) * 240,
                       CENTER_Y + sin($IRB_end_rad) * 240,
                       CENTER_X + cos($IRB_end_rad) * 260,
                       CENTER_Y + sin($IRB_end_rad) * 260
                      );

    #do blanking for labels
    $plastome_ps->setlinewidth(12);
    $plastome_ps->setcolour("white");
    $plastome_ps->arc(CENTER_X, CENTER_Y, 250,
                      ($IRA_start + $IRA_end) / 2 - 3 ,
                      ($IRA_start + $IRA_end) / 2 + 3 );    #blank IRA
    $plastome_ps->arc(CENTER_X, CENTER_Y, 250,
                      ($IRB_start + $IRB_end) / 2 - 3,
                      ($IRB_start + $IRB_end) / 2 + 3);    #blank IRB
    $plastome_ps->arc(CENTER_X, CENTER_Y, 250,
                      ($IRA_end + $IRB_start) / 2 - 3,
                      ($IRA_end + $IRB_start) / 2 + 3);    #blank SSC
    $plastome_ps->arc(CENTER_X, CENTER_Y, 250,
                      ($IRB_end + $IRA_start) / 2 - 3 + 180,
                      ($IRB_end + $IRA_start) / 2 + 3 + 180) ;    #blank LSC
    $plastome_ps->setlinewidth(6);
    $plastome_ps->setcolour("black");

    #label IRA
    $plastome_ps->circletext(CENTER_X, CENTER_Y, 254, ($IRA_start + $IRA_end) / 2, "IRA");

    #label IRB
    $plastome_ps->circletext(CENTER_X, CENTER_Y, 254, ($IRB_start + $IRB_end) / 2, "IRB");

    #label SSC
    $plastome_ps->circletext(CENTER_X, CENTER_Y, 254, ($IRA_end + $IRB_start) / 2, "SSC");

    #label LSC
    $plastome_ps->circletext({align => "outside"}, CENTER_X, CENTER_Y, 246, ($IRB_end + $IRA_start) / 2 + 180, "LSC");

    return $plastome_ps;

};    #end sub _draw_IR

sub _classify_feature
{
	my ($feature, $self) = @_;
	for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
		{
			if (($feature->{type} =~ /${$self->{_drawableFeatures}}[$d]->{type}/i) and 
			($feature->{name} =~ /${$self->{_drawableFeatures}}[$d]->{pattern}/i) and 
			(${$self->{_drawableFeatures}}[$d]->{drawflag})) 
			{
				return ${$self->{_drawableFeatures}}[$d]->{fullname};
			}		 
		}
	 return FALSE;
}

sub _draw_legend
{
    my ($self, $plastome_ps, $fullLegend) = @_;
    my @legend = reverse @{$self->{'_drawableFeatures'}};
#     my @legend = reverse @drawableFeatures;
    # here we have to include code that scans
    # through the feature list and builds up
    # a hash of the feature classes that are 
    # actually found in the list and draw only
    # those in the legend
    my %foundFeatureClasses; 
    foreach my $feature (@{$self->{_featureList}}) {
    	my $fname = _classify_feature($feature, $self);
    	if (defined($fname)) 
    	{
    		$foundFeatureClasses{$fname}++;
    	}
    	
    }
    

    $plastome_ps->setfont("Helvetica", 12);
    my $c = 0;
    for (my $f = 0 ; $f <= $#legend ; $f++)
    {
        unless (defined($fullLegend)) {
        	next if (   ($legend[$f]->{'fullname'} eq '') or (!$legend[$f]->{'drawflag'}));
          	next if (!exists($foundFeatureClasses{$legend[$f]->{'fullname'}})) ;
        }
        # if there is no feature of this class
        # in the annotation don't include it in
#         # the legend!
#         unless (defined($fullLegend)) {
#         	
#        	}
        
        $plastome_ps->setcolour('black');
        $plastome_ps->setlinewidth(2);
        $plastome_ps->box(10, 10 + ($c * 15), 20, 20 + ($c * 15));
        $plastome_ps->text(25, 11 + ($c * 15), $legend[$f]->{'fullname'});
        $plastome_ps->setcolour(@{$legend[$f]->{'color'}});
        $plastome_ps->box({filled => 1},
                          10.1, 10.1 + ($c * 15),
                          19.9, 19.9 + ($c * 15));
        $c++;
    }
};    #end sub _draw_legend

sub _draw_outside_feature
{
    my ($plastome_ps, $extent, $start, $color, $type) = @_;
    my ($c_R, $c_G, $c_B) = @$color;

    # only introns are drawn in white and without a frame
    if ($type eq 'intron')
    {
        $plastome_ps->setlinewidth(24.8);    # Feature in Farbe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $OUTSIDE_FEATURE_RADIUS, $start + 0.1, $extent - 0.1);
        return;
    }
    
    if ($extent - $start > MIN_FRAMED_FEATURE_WIDTH)
    {
        $plastome_ps->setlinewidth(25);    # Featurerahmen in korrekter Gröe
        $plastome_ps->setcolour("black");
        $plastome_ps->arc(CENTER_X, CENTER_Y, $OUTSIDE_FEATURE_RADIUS + 0.6, $start, $extent);

        $plastome_ps->setlinewidth(24.8);    # Feature in Farbe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $OUTSIDE_FEATURE_RADIUS, $start + 0.1, $extent - 0.1);
    }
    else
    {
        $plastome_ps->setlinewidth(25);      # Featurerahmen in korrekter Gröe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $OUTSIDE_FEATURE_RADIUS + 0.6, $start, $extent);
    }
}    #end sub

sub _draw_inside_feature
{
    my ($plastome_ps, $extent, $start, $color, $type) = @_;
    my ($c_R, $c_G, $c_B) = @$color;
    
    # only introns are drawn in white and without a frame
    if ($type eq 'intron')
    {
        $plastome_ps->setlinewidth(24.8);    # Feature in Farbe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $INSIDE_FEATURE_RADIUS, $start + 0.1, $extent - 0.1);
        return;
    }
       
    if ($extent - $start > MIN_FRAMED_FEATURE_WIDTH)
    {
        $plastome_ps->setlinewidth(25);    # Featurerahmen in korrekter Gre
        $plastome_ps->setcolour("black");
        $plastome_ps->arc(CENTER_X, CENTER_Y, $INSIDE_FEATURE_RADIUS - 0.6, $start, $extent);

        $plastome_ps->setlinewidth(24.8);    # Feature in Farbe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $INSIDE_FEATURE_RADIUS, $start + 0.1, $extent - 0.1);
    }
    else
    {
        $plastome_ps->setlinewidth(25);      # Featurerahmen in korrekter Gröe
        $plastome_ps->setcolour($c_R, $c_G, $c_B);
        $plastome_ps->arc(CENTER_X, CENTER_Y, $INSIDE_FEATURE_RADIUS - 0.6, $start, $extent);
    }
}    #end sub

sub _write_outside_label
{
    my $plastome_ps = shift;
    my ($name, $labelangle, $radius, $opt_labelangle, $shiftSSC) = @_;
    $plastome_ps->setcolour("black");
    $plastome_ps->setlinewidth(0.25);
    
    my (
        $opt_string_x, 
        $opt_string_y, 
        $opt_shift_x, 
        $opt_shift_y
        );
    # calculate label coords for unopt label    
    my $string_x = cos($labelangle / 360 * 2 * PI) * $radius;    #umrechnung  in rad * radius der Beschriftung
    my $string_y = sin($labelangle / 360 * 2 * PI) * $radius;
    my $shift_x = sin($labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
    my $shift_y = cos($labelangle / 360 * 2 * PI) * LABEL_SHIFT;
    
    # draw optimized label
    if ($opt_labelangle != ($shiftSSC * (-1)))
    {
        # calculate [x, y] for label after optimization
        my $opt_string_x = cos($opt_labelangle / 360 * 2 * PI) * $OPT_OUTER_RADIUS;    #umrechnung  in rad * radius der Beschriftung
        my $opt_string_y = sin($opt_labelangle / 360 * 2 * PI) * $OPT_OUTER_RADIUS;
        my $opt_shift_x = sin($opt_labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
        my $opt_shift_y = cos($opt_labelangle / 360 * 2 * PI) * LABEL_SHIFT;
        
        if (($labelangle <= 90) or ($labelangle >= 270))
        {
            $plastome_ps->text({rotate => $opt_labelangle},
                           (CENTER_X + $opt_string_x + $opt_shift_x),
                           (CENTER_Y + $opt_string_y - $opt_shift_y), $name)
        }    #end if
        else
        {
        $plastome_ps->text(
                           {align => "right", rotate => ($opt_labelangle + 180)},
                           (CENTER_X + $opt_string_x - $opt_shift_x),
                           (CENTER_Y + $opt_string_y + $opt_shift_y),
                           $name
                          );
        }
        
        #draw line from feature to new label position
        $opt_string_x = cos($opt_labelangle / 360 * 2 * PI) * ($OPT_OUTER_RADIUS - 2);    #umrechnung  in rad * radius der Beschriftung
        $opt_string_y = sin($opt_labelangle / 360 * 2 * PI) * ($OPT_OUTER_RADIUS - 2);
        my $kink_x = cos($labelangle / 360 * 2 * PI) * ($radius + 25);    #umrechnung  in rad * radius der Beschriftung
        my $kink_y = sin($labelangle / 360 * 2 * PI) * ($radius + 25);
        my $kink_shift_x = sin($labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
        my $kink_shift_y = cos($labelangle / 360 * 2 * PI) * LABEL_SHIFT;
        
        $plastome_ps->line(
                           CENTER_X + $string_x,# + $shift_x, 
                           CENTER_Y + $string_y,# + $shift_y,
                           CENTER_X + $kink_x,# + $kink_shift_x, 
                           CENTER_Y + $kink_y,# + $kink_shift_y,
                          );
        $plastome_ps->linextend(
                           CENTER_X + $opt_string_x,# - $opt_shift_x,
                           CENTER_Y + $opt_string_y# - $opt_shift_y,
                            );
        return;  
    }


    # draw unopt label
    if (($labelangle <= 90) or ($labelangle >= 270))
    {
        $plastome_ps->text({rotate => $labelangle},
                           (CENTER_X + $string_x + $shift_x),
                           (CENTER_Y + $string_y - $shift_y), $name)
    }    #end if
    else
    {
        $plastome_ps->text(
                           {align => "right", rotate => ($labelangle + 180)},
                           (CENTER_X + $string_x - $shift_x),
                           (CENTER_Y + $string_y + $shift_y),
                           $name
                          );
    }
    ;                        #end else
}    #end sub


sub _write_inside_label
{
    my $plastome_ps = shift;
    my ($name, $labelangle, $radius, $opt_labelangle, $shiftSSC) = @_;
    $plastome_ps->setcolour("black");
    $plastome_ps->setlinewidth(0.25);

   
    my (
        $opt_string_x, 
        $opt_string_y, 
        $opt_shift_x, 
        $opt_shift_y
        );
    # calculate label coords for unopt label    
    my $string_x = cos($labelangle / 360 * 2 * PI) * $radius;    #umrechnung  in rad * radius der Beschriftung
    my $string_y = sin($labelangle / 360 * 2 * PI) * $radius;
    my $shift_x = sin($labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
    my $shift_y = cos($labelangle / 360 * 2 * PI) * LABEL_SHIFT;
    
    # draw optimized label
    if ($opt_labelangle != ($shiftSSC * (-1)))
    {
        # calculate [x, y] for label after optimization
        my $opt_string_x = cos($opt_labelangle / 360 * 2 * PI) * $OPT_INNER_RADIUS;    #umrechnung  in rad * radius der Beschriftung
        my $opt_string_y = sin($opt_labelangle / 360 * 2 * PI) * $OPT_INNER_RADIUS;
        my $opt_shift_x = sin($opt_labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
        my $opt_shift_y = cos($opt_labelangle / 360 * 2 * PI) * LABEL_SHIFT;
        
        if (($labelangle <= 90) or ($labelangle >= 270))
        {
            $plastome_ps->text({align => "right", rotate => $opt_labelangle},
                           (CENTER_X + $opt_string_x + $opt_shift_x),
                           (CENTER_Y + $opt_string_y - $opt_shift_y), $name)
        }    #end if
        else
        {
        $plastome_ps->text(
                           {rotate => ($opt_labelangle + 180)},
                           (CENTER_X + $opt_string_x - $opt_shift_x),
                           (CENTER_Y + $opt_string_y + $opt_shift_y),
                           $name
                          );
        }
        
        #draw line from feature to new label position
        $opt_string_x = cos($opt_labelangle / 360 * 2 * PI) * ($OPT_INNER_RADIUS + 2);    #umrechnung  in rad * radius der Beschriftung
        $opt_string_y = sin($opt_labelangle / 360 * 2 * PI) * ($OPT_INNER_RADIUS + 2);
        my $kink_x = cos($labelangle / 360 * 2 * PI) * ($radius - 25);    #umrechnung  in rad * radius der Beschriftung
        my $kink_y = sin($labelangle / 360 * 2 * PI) * ($radius - 25);
        my $kink_shift_x = sin($labelangle / 360 * 2 * PI) * LABEL_SHIFT; #Korrektur Schrifthöe von 17.5 bp bei 90 einen halben Buchstaben nach rechts => sin fr x verschiebung
        my $kink_shift_y = cos($labelangle / 360 * 2 * PI) * LABEL_SHIFT;
        
        $plastome_ps->line(
                           CENTER_X + $string_x,# + $shift_x, 
                           CENTER_Y + $string_y,# + $shift_y,
                           CENTER_X + $kink_x,# + $kink_shift_x, 
                           CENTER_Y + $kink_y,# + $kink_shift_y,
                          );
        $plastome_ps->linextend(
                           CENTER_X + $opt_string_x,# - $opt_shift_x,
                           CENTER_Y + $opt_string_y# - $opt_shift_y,
                            );
        return;  
    }


    # draw unopt label
    if (($labelangle <= 90) or ($labelangle >= 270))
    {
        $plastome_ps->text(
                           {align => "right", rotate => $labelangle},
                           (CENTER_X + $string_x + $shift_x),
                           (CENTER_Y + $string_y - $shift_y),
                           $name
                          );
    }    #end if
    else
    {
        $plastome_ps->text({rotate => ($labelangle + 180)},
                           (CENTER_X + $string_x - $shift_x),
                           (CENTER_Y + $string_y + $shift_y), $name);
    }
    ;                       #end else
}    #end sub

sub _draw_GC_graph
{
    my ($self) = shift;
    my $shiftSSC = shift;
    my $ps_map = $self->{_psMap};
    my $seq = $self->{_seqobj}->seq();
    my $GCvalue;
    
    # the windowsize for GC content calculation
    # is calculated dynamically to give 3CENTER_Y
    # windows (0.1 each)
    my $window_size = length($seq) / 3600; 
    
    print "\ncalculating GC content graph...<br>\n";
    $self->{_psMap}->setlinewidth(50);
    $self->{_psMap}->setcolour(220,220,220);
    $self->{_psMap}->circle(CENTER_X,CENTER_Y,225);
     
    
    for (my $c = 0; $c <= 3599; $c++)
    {
        $GCvalue = _calcGC(substr($seq, ($c*$window_size), int($window_size)));
        _draw_GC_bar($self, $GCvalue, (($c + ($window_size / 2)) / 10) - $shiftSSC);
    }
}

sub _draw_GC_bar
{
    my ($self, $value, $angle) = @_;
    #draw dashes for begin & end of IRB
    
    $self->{_psMap}->setcolour(180,180,180);
    $self->{_psMap}->setlinewidth(1);    
    $self->{_psMap}->line(
                       CENTER_X + cos($angle * 2 * PI / 360) * (250 - ($value /2 )),
                       CENTER_Y + sin($angle * 2 * PI / 360) * (250 - ($value /2 )),
                       CENTER_X + cos($angle * 2 * PI / 360) * 250,
                       CENTER_Y + sin($angle * 2 * PI / 360) * 250
                      );

}


############################
#    HELPER SUBROUTINES    #
############################

sub _calcGC
{
    my $seq = shift;
    my @hits = $seq =~ /(g|c)/gi;
	my $gc;
    	eval {
		$gc = ((scalar(@hits)) / length($seq)) * 100;
	};
	if ($@) {$gc = 0;}
	
	return $gc;
	 
	
    
}

sub _tidy_up_name
{
    my $name = shift;
    
    # reformat rRNA labeling
    $name =~ s/^(.*)s ribosomal rna|^(.*) ribosomal rna/rrn$1/ig;
    $name =~s/^(.*)(s).?r(r|d)na/rrn$1/ig;
    
    
    # reformat different ways of tRNA labeling
    if ($name =~ /trna.(.{2,3}).?\((...)\)/ig)
    {
        my $codon = uc($2);
        #$codon =~ s/U/T/ig;
        $codon = '' if (length($2) != 3); #needs refinement
        $name = "trn".$three_to_1{$1}."-$codon";
    }
    
    if ($name =~ /trn(.)\(([aAtTuUgGcC]{3})\)/ig)
    {
        my $codon = uc($2);
        $name = "trn$1-$codon";
        return $name;
    }
    
    if (($name =~ /trna.(...)/ig) && !($name =~ /trnA./))
    {
        $name = "trn".$three_to_1{$1};
        return $name;
    }
    
    if ($name =~ /codon(s){0,1} recognized:\s*([\w]{3})/ig)
    {
        my $codon = uc($2);
        
        # brute force replace RNA and IUPAC "wobble" nucleic
        # acid codes to DNA codes that can be translated using
        # the Bio::Seq translate method
        $codon =~ tr/URYKMSWBDHV/TACGACACAAA/;
        my $display_codon = uc($2);
        my $seq = Bio::Seq->new();
        $seq->seq($codon);
        my $aa = $seq->translate()->seq();
        $name = "trn$aa -$display_codon";
    }
    return $name;
}


sub _is_element_of
{
    my $test  = shift;
    my @array = @_;
    foreach my $e (@array)
    {
        return TRUE if ($e eq $test);
    }
    return FALSE;
}    #end sub

sub _unique #http://www.rocketaware.com/perl/perlfaq4/How_can_I_extract_just_the_uniqu.htm
{
    my @orig_array = @_;
    my @out;
    my %saw;
    undef %saw;
    @out = grep(!$saw{$_}++, @orig_array);
    return @out;
}           #end sub _unique

sub _is_drawable_feature
{
	my ($self, $test, $p_color) = @_;
	
	## silly
	if ($self->{_organelle} =~ /mitoch/i) {
		return GeneMap::Chondriome::_is_drawable_feature( $self, $test, $p_color);
	}
	
	for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
			{
# 				print Dumper(${$self->{_drawableFeatures}}[$d])."<br>";
# 				print ${$self->{_drawableFeatures}}[$d]."<br>";

				if (
					($test->{type} =~ /${$self->{_drawableFeatures}}[$d]->{type}/i) && 
					($test->{name} =~ /${$self->{_drawableFeatures}}[$d]->{pattern}/i) && 
					(${$self->{_drawableFeatures}}[$d]->{drawflag})
				) 
				{
					${$p_color} = ${$self->{_drawableFeatures}}[$d]->{color} unless (!$p_color);
					return TRUE;
				}		 
			}
	 return FALSE;
}

## we need this to properly determine other genes class genes

sub _is_default_drawable_feature
{
	my ($self, $test, $p_color) = @_;
	
	## silly
	if ($self->{_organelle} =~ /mitoch/i) {
		return GeneMap::Chondriome::_is_default_drawable_feature( $self, $test, $p_color);
	}
	
	for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
			{
				if (($test->{type} =~ /$drawable_features[$d]->{type}/i) and 
				($test->{name} =~ /$drawable_features[$d]->{pattern}/i) 
# 				and (@drawable_features[$d]->{drawflag})
				) 
				{
# 				print"PLASTOME";
				${$p_color} = $drawable_features[$d]->{color} unless (!$p_color);
				return TRUE;
				}		 
			}
	 return FALSE;
}



sub _sum
{
    my @arr = @_;
    my $sum = 0;
    foreach my $a (@arr)
    {
        $sum += $a;
    }
    return $sum;
}

sub _min
{
    my @testarray      = @_;
    my $smallest_value = 10000000;
    foreach my $elem (@testarray)
    {
        $smallest_value = $elem if ($elem < $smallest_value);
    }
    return $smallest_value;
}

sub _max
{
    my @testarray     = @_;
    my $biggest_value = 0;
    foreach my $elem (@testarray)
    {
        $biggest_value = $elem if ($elem > $biggest_value);
    }
    return $biggest_value;
}


sub _calc_shiftSSC
{
	my $self = shift;
	my $seqobj = $self->{_seqobj};
	
	my $IRA_start = $self->{_IRAstart};
	my $IRA_end = $self->{_IRAend};
	my $IRB_start = $self->{_IRBstart};
	my $IRB_end = $self->{_IRBend};	
	
    return 0 if ((!$IRA_start) || (!$IRA_end) || (!$IRB_start) || (!$IRB_end));
    
    $IRA_start = ($IRA_start / $seqobj->length()) * 360;
    $IRA_end   = ($IRA_end / $seqobj->length()) * 360;
    $IRB_start = ($IRB_start / $seqobj->length()) * 360;
    $IRB_end   = ($IRB_end / $seqobj->length()) * 360;

    my $center_ssc = ($IRA_end + $IRB_start)/2;
    my $shift_ssc = $center_ssc - 270;
    	
    return $shift_ssc;
	
}

###

END 
{ 
    # zilch 
}     
1;

__END__

=head1 AUTHORS

Marc Lohse  and Oliver Drechsel

Max-Planck-Institute of molecular plant physiology

Dept. Bock

Am Muehlenberg 1

14476 Potsdam-Golm

lohse@mpimp-golm.mpg.de

drechsel@mpimp-golm.mpg.de

=cut

